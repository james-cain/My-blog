(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{174:function(e,t,r){"use strict";r.r(t);var n=r(0),s=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),r("p",[e._v("Progressive Web App，简称PWA，是提升Web App的体验的一种新方法，能给用户原生应用的体验。")]),e._v(" "),r("p",[e._v("PWA能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA本质上是Web App，借助一些新技术具备了Native App的一些特性，兼具Web App和Native App的优点。")]),e._v(" "),r("p",[e._v("特点：")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),r("p",[e._v("要安装Service Worker，需要通过在js主线程（常规的页面里的js）注册Service Worker来启动安装，这个过程会通知浏览器Service Worker线程的javaScript文件在什么地方呆着")]),e._v(" "),e._m(7),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),r("p",[e._v("可以用"),r("router-link",{attrs:{to:"./chrome://inspect/#service-workers"}},[e._v("service-worker-inspect")])],1),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),r("p",[e._v("注册成功后，就已经有了属于web app的worker context了。接下来浏览器会不停的尝试在站点里的页面安装并激活它，并且在这里可以把静态资源的缓存给办了")]),e._v(" "),r("p",[e._v("install事件会绑定在Service Worker文件中，在Service Worker安装成功后，install事件被触发。")]),e._v(" "),r("p",[e._v("install事件一般是被用来填充你的浏览器的离线缓存能力。Service Worker使用的是一个cache API的全局对象，它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key。这个API和浏览器的标准的缓存工作原理很相似，但是只对应在站点的域中。会一直持久存在直到告诉它不在存储")]),e._v(" "),r("p",[e._v("local storage是同步的用法在Service Worker中不允许使用")]),e._v(" "),r("p",[e._v("IndexedDB可以在Service Worker内做数据存储")]),e._v(" "),e._m(15),r("p",[e._v("ExtendableEvent.waitUtil()方法—确保Service Worker不会再waitUtil()里面的代码执行之前安装完成")]),e._v(" "),e._m(16),e._v(" "),r("p",[e._v("每次任何被Service Worker控制的资源被请求时，都会触发fetch事件，这些资源包括了指定的scope内的html文档，和这些html文档内引用的其他任何资源。")]),e._v(" "),e._m(17),e._m(18),e._v(" "),r("p",[e._v("两种方式可以比较一下：")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),r("p",[e._v("若/sw.js缓存策略要更新该怎么处理？")]),e._v(" "),r("p",[e._v("如果/sw.js内容有更新，当访问网站页面时浏览器获取了新的文件，逐字节比对/sw.js文件发现不同时会认为有更新启动更新算法，于是会安装新的文件并触发install事件。但是此时已经处于激活状态的旧的Service Worker还在运行，新的Service Worker完成安装后会进入waiting状态。直到所有已打开的页面都关闭，旧的Service Worker自动停止，新的Service Worker才会在接下来重新打开的页面里生效。")]),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),e._m(27),e._m(28),e._v(" "),r("p",[e._v("在页面脚本中注册Service Worker文件所在的URL。Worker就可以开始激活了，激活后的Service Worker可以监听当前域下的功能性事件，比如资源请求（fetch）、推送通知（push）、后台同步（sync）。")]),e._v(" "),r("p",[e._v("Service Worker基本步骤：")]),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),r("p",[e._v("这里特别说明一下，进入废弃 (redundant) 状态的原因可能为这几种：")]),e._v(" "),e._m(36),e._v(" "),e._m(37),e._v(" "),r("ul",[e._m(38),e._v(" "),e._m(39),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),r("li",[r("strong",[e._v("push (推送)")]),e._v("：push 事件是为推送准备的。不过首先需要了解一下 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/notification",target:"_blank",rel:"noopener noreferrer"}},[e._v("Notification API"),r("OutboundLink")],1),e._v(" 和 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API",target:"_blank",rel:"noopener noreferrer"}},[e._v("PUSH API"),r("OutboundLink")],1),e._v("。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。")]),e._v(" "),e._m(42)]),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),e._m(45),e._v(" "),r("p",[e._v("选项含义：")]),e._v(" "),e._m(46),e._v(" "),e._m(47),e._v(" "),r("p",[e._v("Service Worker 使用 Cache API 缓存只读资源，我们同样可以在 Chrome DevTools 上查看缓存的资源列表。")]),e._v(" "),r("p",[e._v("Cache Storage 选项卡提供了一个已使用（Service Worker 线程）Cache API 缓存的只读资源列表。")]),e._v(" "),e._m(48),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),e._m(51),e._v(" "),r("p",[e._v("对于网址可寻址的资源，使用"),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Cache",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cache API"),r("OutboundLink")],1),e._v("（服务工作线程的一部分）。")]),e._v(" "),r("p",[e._v("对于所有其他的数据，使用 "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",target:"_blank",rel:"noopener noreferrer"}},[e._v("IndexedDB"),r("OutboundLink")],1),e._v("（具有一个 Promise 包装器）。")]),e._v(" "),e._m(52),e._v(" "),e._m(53),e._v(" "),e._m(54),e._v(" "),e._m(55),e._v(" "),r("p",[e._v("WebSQL不具有广泛的浏览器支持，不建议使用。")]),e._v(" "),r("p",[e._v("File System API在Chrome以外的任意浏览器上都不受支持。")]),e._v(" "),e._m(56),e._v(" "),e._m(57),e._v(" "),e._m(58),e._v(" "),r("p",[e._v("在chrome中，可以使用"),r("a",{attrs:{href:"https://www.w3.org/TR/quota-api/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Quota Management API "),r("OutboundLink")],1),e._v("查询目前使用的存储空间大小")]),e._v(" "),e._m(59),e._v(" "),e._m(60),e._v(" "),e._m(61),e._v(" "),r("p",[e._v("PWA提供了manifest.json配置文件，可以让开发者自定义添加至桌面时的图标、显示名称、启动方式等信息，并提供API方便开发者管理网络应用安装横幅，让用户可以方便快捷地将站点添加到主屏幕。")]),e._v(" "),r("p",[e._v("通过配置manifest.json进行相应配置，可以实现以下功能：")]),e._v(" "),e._m(62),e._v(" "),e._m(63),e._v(" "),e._m(64),e._v(" "),e._m(65),e._v(" "),e._m(66),e._v(" "),e._m(67),e._v(" "),r("p",[e._v("其中ImageObject的属性值包括：")]),e._v(" "),e._m(68),e._v(" "),e._m(69),e._v(" "),e._m(70),e._v(" "),e._m(71),e._v(" "),e._m(72),e._v(" "),r("p",[e._v("如果为空，则默认使用当前页面。如果start_url配置的相对地址，则基地址与manifest.json相同。")]),e._v(" "),e._m(73),e._v(" "),r("p",[e._v("有时仅仅对站点的某些模块进行PWA改造，其余部分还是普通的网页。因此超出范围的部分会以浏览器的方式显示。")]),e._v(" "),e._m(74),e._v(" "),r("p",[e._v("scope应遵循如下规则：")]),e._v(" "),e._m(75),e._v(" "),e._m(76),e._v(" "),r("p",[e._v("可以设置display属性去指定PWA从主屏幕点击启动后的显示类型")]),e._v(" "),e._m(77),e._v(" "),r("p",[e._v("显示类型：")]),e._v(" "),e._m(78),e._v(" "),e._m(79),e._v(" "),e._m(80),e._m(81),e._v(" "),e._m(82),e._v(" "),r("p",[e._v("主要有几种：")]),e._v(" "),e._m(83),e._v(" "),e._m(84),e._v(" "),r("p",[e._v("控住浏览器UI的颜色。如PWA启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被theme_color所影响")]),e._v(" "),e._m(85),e._v(" "),e._m(86),e._v(" "),e._m(87),e._v(" "),r("p",[e._v("浏览器在PWA站点满足以下条件时会自动显示横幅：")]),e._v(" "),e._m(88),e._v(" "),e._m(89),e._v(" "),r("p",[e._v("浏览器在PWA站点满足以下条件时会自动显示横幅：")]),e._v(" "),e._m(90),e._v(" "),r("p",[e._v("其中related_applications的定义如下:")]),e._v(" "),e._m(91),e._v(" "),r("p",[e._v('如果只希望用户安装原生应用，不需要弹出横幅引导用户安装，可以设置："prefer_related_applications": true')]),e._v(" "),e._m(92),e._v(" "),r("p",[e._v("即使浏览器关闭的情况下，网络推送通知也可以像原生APP那样进行消息推送，并将推送的消息显示在通知栏里。")]),e._v(" "),e._m(93),e._v(" "),e._m(94),e._v(" "),e._m(95),e._v(" "),r("p",[e._v("ios11版本已经全面兼容pwa，研究研究~")]),e._v(" "),e._m(96),e._v(" "),r("p",[e._v("配置app的挑战在于理解ios和android的metas标签和web app manifest的不同，先要理解每个配置的作用。")]),e._v(" "),r("p",[e._v("糟糕的是，对于ios，要创建大量的标签适配各种屏幕和想要的方向，否则用户将会在你启动的app中看到白屏。")]),e._v(" "),e._m(97),e._m(98),e._v(" "),r("p",[e._v("可以在安装的pwas中使用css media queries")]),e._v(" "),e._m(99),r("p",[e._v("切换不同可视pwas的javascript")]),e._v(" "),e._m(100)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"pwa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwa","aria-hidden":"true"}},[this._v("#")]),this._v(" PWA")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("strong",[e._v("可靠")]),e._v("-即使在不稳定的网络环境下，也能瞬间加载并展现")]),e._v(" "),r("li",[r("strong",[e._v("体验")]),e._v("-快速响应了，并且有平滑的动画响应用户的操作")]),e._v(" "),r("li",[r("strong",[e._v("粘性")]),e._v("-像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"离线和缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离线和缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" 离线和缓存")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker","aria-hidden":"true"}},[this._v("#")]),this._v(" Service Worker")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"前提条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前提条件","aria-hidden":"true"}},[this._v("#")]),this._v(" 前提条件")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("Service Worker"),r("strong",[e._v("要求HTTPS的环境")]),e._v("，通常可以借助github page进行学习调试。或者用"),r("strong",[e._v("localhost、127.0.0.1")]),e._v("浏览器也允许调试Service Worker")]),e._v(" "),r("li",[e._v("Service Worker的"),r("strong",[e._v("缓存机制")]),e._v("依赖于"),r("strong",[e._v("Cache API")]),e._v("实现")]),e._v(" "),r("li",[e._v("依赖HTML5 "),r("strong",[e._v("fetch API")])]),e._v(" "),r("li",[e._v("依赖"),r("strong",[e._v("Promise")]),e._v("实现")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"注册"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注册","aria-hidden":"true"}},[this._v("#")]),this._v(" 注册")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("if ('serviceWorker' in navigation) {\n    window.addEventListener('load', function() {\n        navigation.serviceWorker.register('/sw.js', {scope: '/'}).then(function(registration) {\n            // 注册成功\n            console.log('ServiceWorker registration successful with scope:' + registration.scope);\n        }).catch(function(err) {\n            // 注册失败\n            console.log('ServiceWorker registration failed:' + err);\n        });\n    });\n}\n")])])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("首先要判断ServiceWorker API在浏览器中是否可用，支持的话才继续实现")]),e._v(" "),r("li",[e._v("接下来在页面onload的时候注册位于./sw.js的Service Worker")]),e._v(" "),r("li",[e._v("每次页面加载成功后，就会调用register()方法，浏览器将会判断ServiceWorker线程是否已注册并作出相应的处理")]),e._v(" "),r("li",[e._v("register方法的scope参数是可选的，用于指定让Service Worker控制的内容的子目录。以上demo服务工作线程文件位于根网域，意味着服务工作线程的作用域将是整个来源")]),e._v(" "),r("li",[e._v("说明register方法的"),r("strong",[e._v("scope参数")]),e._v("："),r("strong",[e._v("ServiceWorker线程将接收scope指定网域目录上所有事项的fetch事件")]),e._v("，如果我们的ServiceWorker的JavaScript文件在/a/b/sw.js，不传scope值的情况下，scope的值就是/a/b")]),e._v(" "),r("li",[e._v("scope的值得意义在于如果scope的值为/a/b，那么ServiceWorker线程只能捕获到path为/a/b开头的（/a/b/page1，/a/b/page2，…）页面的fetch事件。通过scope的意义也能看出ServiceWorker不是服务单个页面的，所以在ServiceWorker的js逻辑中全局变量需要慎用")]),e._v(" "),r("li",[e._v("then()函数链式调用promise，当promise resolve的时候，里面的代码就会执行")]),e._v(" "),r("li",[e._v("最后链了一个catch()函数，当promise rejected才会执行")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("代码执行完成之后，就注册了一个Service Worker，它工作在worker context，所以"),t("strong",[this._v("没有访问DOM的权限")]),this._v("。在正常的页面之外运行Service Worker的代码来控制他们的加载。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"查看是否注册成功"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看是否注册成功","aria-hidden":"true"}},[this._v("#")]),this._v(" 查看是否注册成功")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("还可以通过"),t("a",{attrs:{href:"chrome://serviceworker-internals"}},[this._v("service-worker-internals")]),this._v("来查看服务工作线程详情。如果只是很想了解服务工作线程的生命周期，这很有用，但很有可能被上者取代")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"注册失败的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注册失败的原因","aria-hidden":"true"}},[this._v("#")]),this._v(" 注册失败的原因")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("不是HTTPS环境，不是localhost或127.0.0.1")]),this._v(" "),t("li",[this._v("Service Worker文件的地址没有写对，需要相对于origin")]),this._v(" "),t("li",[this._v("Service Worker文件在不同的origin下而不是你的APP的，是不被允许的")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装","aria-hidden":"true"}},[this._v("#")]),this._v(" 安装")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("// 监听service worker的install事件\nthis.addEventListener('install', function(event) {\n\t// 如果监听到了service worker已经安装成功的话，就会调用event.waitUntil回调函数\n\tevent.waitUtil(\n\t\t// 安装成功后操作CacheStorage缓存，使用之前需要caches.open()打开对应缓存空间\n\t\tcaches.open('my-test-cache-v1').then(function(cache) {\n            // 通过cache缓存对象的addAll方法添加precache缓存\n            return cache.addAll([\n                '/',\n                '/index.html',\n                '/main.css',\n                '/main.js',\n                '/image.jpg'\n            ])\n\t\t})\n\t)\n})\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"自定义请求响应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义请求响应","aria-hidden":"true"}},[this._v("#")]),this._v(" 自定义请求响应")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("this.addEventListener('fetch', function (event) {\n    event.respondWith(\n        caches.match(event.request).then(function (response) {\n            // 如果 Service Worker 有自己的返回，就直接返回，减少一次 http 请求\n            if (response) {\n                return response;\n            }\n\n            // 如果 service worker 没有返回，那就得直接请求真实远程服务\n            var request = event.request.clone(); // 把原始请求拷过来\n            return fetch(request).then(function (httpRes) {\n\n                // http请求的返回已被抓到，可以处置了。\n\n                // 请求失败了，直接返回失败的结果就好了。。\n                if (!httpRes || httpRes.status !== 200) {\n                    return httpRes;\n                }\n\n                // 请求成功的话，将请求缓存起来。\n                var responseClone = httpRes.clone();\n                caches.open('my-test-cache-v1').then(function (cache) {\n                    cache.put(event.request, responseClone);\n                });\n\n                return httpRes;\n            });\n        })\n    );\n});\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("因此，缓存静态资源可以通过两种方式，在"),t("strong",[this._v("install")]),this._v("的时候进行和在"),t("strong",[this._v("fetch事件处理回调")]),this._v("的时候动态实现")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("on install 的优点是第二次访问即可离线，缺点是需要将需要缓存的 URL 在编译时插入到脚本中，增加代码量和降低可维护性；")]),this._v(" "),t("li",[this._v("on fetch 的优点是无需更改编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线可用。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"service-worker版本更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker版本更新","aria-hidden":"true"}},[this._v("#")]),this._v(" service worker版本更新")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"自动更新所有页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动更新所有页面","aria-hidden":"true"}},[this._v("#")]),this._v(" 自动更新所有页面")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("可以在install事件中执行**self.skipWaiting()"),t("strong",[this._v("方法跳过waiting状态，然后会直接进入activate阶段。接着在activate事件发生时，通过执行")]),this._v("self.clients.claim()**方法，更新所有客户端上的Service Worker。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("// 安装阶段跳过等待，直接进入 active\nself.addEventListener('install', function (event) {\n    event.waitUntil(self.skipWaiting());\n});\n\nself.addEventListener('activate', function (event) {\n    event.waitUntil(\n        Promise.all([\n\n            // 更新客户端\n            self.clients.claim(),\n\n            // 清理旧版本\n            caches.keys().then(function (cacheList) {\n                return Promise.all(\n                    cacheList.map(function (cacheName) {\n                        if (cacheName !== 'my-test-cache-v1') {\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n        ])\n    );\n});\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("另外要注意一点，"),t("strong",[this._v("/sw.js文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件")]),this._v("。这会导致更新得不到响应。因此，"),t("strong",[this._v("在Web Server上添加对该文件的过滤规则，不缓存或设置较短的有效期")]),this._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"手动更新service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手动更新service-worker","aria-hidden":"true"}},[this._v("#")]),this._v(" 手动更新Service Worker")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在"),t("strong",[this._v("页面")]),this._v("中，可以借助"),t("strong",[this._v("Registration.update()更新")]),this._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("var version='1.0.1';\nnavigator.serviceWorker.register('/sw.js').then(function(reg) {\n    if (localStorage.getItem('sw_version') !== version) {\n        reg.update().then(function () {\n            localStorage.setItem('sw_version', version);\n        });\n    }\n});\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期","aria-hidden":"true"}},[this._v("#")]),this._v(" 生命周期")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("首先我们需要在页面的 JavaScript 主线程中使用 "),r("code",[e._v("serviceWorkerContainer.register()")]),e._v(" 来注册 Service Worker ，在注册的过程中，浏览器会在后台启动尝试 Service Worker 的安装步骤。")]),e._v(" "),r("li",[e._v("如果注册成功，Service Worker 在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊的 worker context，与主脚本的运行线程相独立，同时也没有访问 DOM 的能力。")]),e._v(" "),r("li",[e._v("后台开始安装步骤， 通常在安装的过程中需要缓存一些静态资源。如果所有的资源成功缓存则安装成功，如果有任何静态资源缓存失败则安装失败，在这里失败的不要紧，会自动继续安装直到安装成功，如果安装不成功无法进行下一步 — 激活 Service Worker。")]),e._v(" "),r("li",[e._v("开始激活 Service Worker，必须要在 Service Worker 安装成功之后，才能开始激活步骤，当 Service Worker 安装完成后，会接收到一个激活事件（activate event）。激活事件的处理函数中，主要操作是清理旧版本的 Service Worker 脚本中使用资源。")]),e._v(" "),r("li",[e._v("激活成功后 Service Worker 可以控制页面了，但是只针对在成功注册了 Service Worker 后打开的页面。也就是说，页面打开时有没有 Service Worker，决定了接下来页面的生命周期内受不受 Service Worker 控制。所以，只有当页面刷新后，之前不受 Service Worker 控制的页面才有可能被控制起来。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://coracain.top/assets/sw-lifecycle.png",alt:"sw-lifecycle"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("strong",[this._v("安装( installing )")]),this._v("：这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("code",[this._v("install")]),this._v(" 事件回调中有两个方法：")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("code",[e._v("event.waitUntil()")]),e._v("：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。")]),e._v(" "),r("li",[r("code",[e._v("self.skipWaiting()")]),e._v("："),r("code",[e._v("self")]),e._v(" 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。")]),e._v(" "),r("li",[r("strong",[e._v("安装后( installed )")]),e._v("：Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。")]),e._v(" "),r("li",[r("strong",[e._v("激活( activating )")]),e._v("：在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("code",[this._v("activate")]),this._v(" 回调中有两个方法：")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("code",[e._v("event.waitUntil()")]),e._v("：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。")]),e._v(" "),r("li",[r("code",[e._v("self.clients.claim()")]),e._v("：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。")]),e._v(" "),r("li",[r("strong",[e._v("激活后( activated )")]),e._v("：在这个状态会处理 "),r("code",[e._v("activate")]),e._v(" 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 "),r("code",[e._v("fetch (请求)")]),e._v("、"),r("code",[e._v("sync (后台同步)")]),e._v("、"),r("code",[e._v("push (推送)")]),e._v("。")]),e._v(" "),r("li",[r("strong",[e._v("废弃状态 ( redundant )")]),e._v("：这个状态表示一个 Service Worker 的生命周期结束。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("安装 (install) 失败")]),this._v(" "),t("li",[this._v("激活 (activating) 失败")]),this._v(" "),t("li",[this._v("新版本的 Service Worker 替换了它并成为激活状态")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"支持的事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持的事件","aria-hidden":"true"}},[this._v("#")]),this._v(" 支持的事件")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("strong",[this._v("install")]),this._v("：Service Worker 安装成功后被触发的事件，在事件处理函数中可以添加需要缓存的文件")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("strong",[this._v("activate")]),this._v("：当 Service Worker 安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对旧版本的更新、对无用缓存的清理等。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("strong",[this._v("message")]),this._v("：Service Worker 运行于独立 context 中，无法直接访问当前页面主线程的 DOM 等信息，但是通过 postMessage API，可以实现他们之间的消息传递，这样主线程就可以接受 Service Worker 的指令操作 DOM。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("strong",[this._v("fetch (请求)")]),this._v("：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response 参数的回调函数，回调中就可以做各种代理缓存的事情了。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("strong",[this._v("sync (后台同步)")]),this._v("：sync 事件由 background sync (后台同步)发出。background sync 配合 Service Worker 推出的 API，用于为 Service Worker 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C Web API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 "),t("code",[this._v("chrome://flags/#enable-experimental-web-platform-features")]),this._v(" ，开启该功能，然后重启生效。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"chrome浏览器debug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chrome浏览器debug","aria-hidden":"true"}},[this._v("#")]),this._v(" chrome浏览器debug")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("使用 Chrome 浏览器，可以通过进入控制台 "),t("code",[this._v("Application -> Service Workers")]),this._v(" 面板查看和调试。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:"https://coracain.top/assets/chrome_debug.png",alt:"chrome_debug"}})])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[r("strong",[e._v("offline")]),e._v("： 复选框可以将 DevTools 切换至离线模式。它等同于 Network 窗格中的离线模式。")]),e._v(" "),r("li",[r("strong",[e._v("Update on reload")]),e._v("：复选框可以强制 Service Worker 线程在每次页面加载时更新。")]),e._v(" "),r("li",[r("strong",[e._v("Bypass for network")]),e._v("：复选框可以绕过 Service Worker 线程并强制浏览器转至网络寻找请求的资源。")]),e._v(" "),r("li",[r("strong",[e._v("Update")]),e._v("：按钮可以对指定的 Service Worker 线程执行一次性更新。")]),e._v(" "),r("li",[r("strong",[e._v("Push")]),e._v("：按钮可以在没有负载的情况下模拟推送通知。")]),e._v(" "),r("li",[r("strong",[e._v("Sync")]),e._v("：按钮可以模拟后台同步事件。")]),e._v(" "),r("li",[r("strong",[e._v("Unregister")]),e._v("：按钮可以注销指定的 Service Worker 线程。")]),e._v(" "),r("li",[r("strong",[e._v("Source")]),e._v("：告诉您当前正在运行的 Service Worker 线程的安装时间。 链接是 Service Worker 线程源文件的名称。点击链接会将您定向至 Service Worker 线程来源。")]),e._v(" "),r("li",[r("strong",[e._v("Status")]),e._v("：告诉您 Service Worker 线程的状态。此行上的数字（上方屏幕截图中的 #1）指示 Service Worker 线程已被更新的次数。如果启用 "),r("code",[e._v("update on reload")]),e._v("复选框，您会注意到每次页面加载时此数字都会增大。在状态旁边，您将看到 "),r("code",[e._v("start")]),e._v(" 按钮（如果 Service Worker 线程已停止）或 "),r("code",[e._v("stop")]),e._v(" 按钮（如果 Service Worker 线程正在运行）。 Service Worker 线程设计为可由浏览器随时停止和启动。 使用 stop 按钮明确停止 Service Worker 线程可以模拟这一点。停止 Service Worker 线程是测试 Service Worker 线程再次重新启动时的代码行为方式的绝佳方法。它通常可以揭示由于对持续全局状态的不完善假设而引发的错误。")]),e._v(" "),r("li",[r("strong",[e._v("Clients")]),e._v("：告诉您 Service Worker 线程作用域的原点。 如果您已启用 "),r("code",[e._v("show all")]),e._v("复选框，"),r("code",[e._v("focus")]),e._v(" 按钮将非常实用。 在此复选框启用时，系统会列出所有注册的 Service Worker 线程。 如果您点击正在不同标签中运行的 Service Worker 线程旁的 "),r("code",[e._v("focus")]),e._v(" 按钮，Chrome 会聚焦到该标签。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"查看service-worker缓存内容"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看service-worker缓存内容","aria-hidden":"true"}},[this._v("#")]),this._v(" 查看Service worker缓存内容")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"网络跟踪"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络跟踪","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络跟踪")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("经过 Service Worker 的 "),t("code",[this._v("fetch")]),this._v(" 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("来自 Service Worker 的内容会在 Size 字段中标注为 "),t("code",[this._v("from ServiceWorker")])]),this._v(" "),t("li",[this._v("Service Worker 发出的请求会在 Name 字段中添加 ⚙ 图标。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"pwa的离线存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwa的离线存储","aria-hidden":"true"}},[this._v("#")]),this._v(" PWA的离线存储")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("以上两个API都是异步的（IndexedDB基于事件，CacheAPI基于Promise）。它们使用"),t("strong",[this._v("网页工作线程")]),this._v("、"),t("strong",[this._v("窗口")]),this._v("和"),t("strong",[this._v("服务工作线程")]),this._v("。IndexedDB在每个位置都可用。服务工作线程（和CacheAPI）目前在Chrome、Firefox、Opera中可用，并正在针对Edge进行开发。IndexedDB的Promise包装器隐藏了IndexedDB库自带的一些强大但同时也非常复杂的machinery（如事务处理、架构版本）。IndexedDB将支持observers，可以轻松实现标签之间的同步。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"其他存储机制怎样？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他存储机制怎样？","aria-hidden":"true"}},[this._v("#")]),this._v(" 其他存储机制怎样？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Web Storage（如LocalStorage和SessionStorage）是同步的，"),t("strong",[this._v("不支持网页工作线程")]),this._v("，并对大小和类型（仅限字符串）进行限制。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Cookie具有自身的用途，也是同步的，"),t("strong",[this._v("缺少网页工作线程支持")]),this._v("，同时对大小进行限制。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"能存储多少数据？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#能存储多少数据？","aria-hidden":"true"}},[this._v("#")]),this._v(" 能存储多少数据？")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",[r("thead",[r("tr",[r("th",[e._v("浏览器")]),e._v(" "),r("th",[e._v("限制")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Chrome")]),e._v(" "),r("td",[e._v("可用空间 <6%")])]),e._v(" "),r("tr",[r("td",[e._v("Firefox")]),e._v(" "),r("td",[e._v("可用空间 <10%（但在存储50M数据后将提示用户进行更多存储请求）")])]),e._v(" "),r("tr",[r("td",[e._v("Safari")]),e._v(" "),r("td",[e._v("<50MB")])]),e._v(" "),r("tr",[r("td",[e._v("IE10")]),e._v(" "),r("td",[e._v("<250MB（并在存储10MB后提示用户）")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"了解应用使用功能了多少存储空间？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#了解应用使用功能了多少存储空间？","aria-hidden":"true"}},[this._v("#")]),this._v(" 了解应用使用功能了多少存储空间？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"缓存逐出是如何工作的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存逐出是如何工作的？","aria-hidden":"true"}},[this._v("#")]),this._v(" 缓存逐出是如何工作的？")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",[r("thead",[r("tr",[r("th",[e._v("浏览器")]),e._v(" "),r("th",[e._v("逐出政策")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Chrome")]),e._v(" "),r("td",[e._v("在 Chrome 耗尽空间后采用 LRU 策略")])]),e._v(" "),r("tr",[r("td",[e._v("Firefox")]),e._v(" "),r("td",[e._v("在整个磁盘已装满时采用 LRU 策略")])]),e._v(" "),r("tr",[r("td",[e._v("Safari")]),e._v(" "),r("td",[e._v("无逐出")])]),e._v(" "),r("tr",[r("td",[e._v("Edge")]),e._v(" "),r("td",[e._v("无逐出")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"添加到主屏幕"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加到主屏幕","aria-hidden":"true"}},[this._v("#")]),this._v(" 添加到主屏幕")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("基本功能\n"),r("ul",[r("li",[e._v("自定义名称")]),e._v(" "),r("li",[e._v("自定义图标")]),e._v(" "),r("li",[e._v("设置启动网址")]),e._v(" "),r("li",[e._v("设置作用域")])])]),e._v(" "),r("li",[e._v("改善应用功能体验\n"),r("ul",[r("li",[e._v("添加启动画面")]),e._v(" "),r("li",[e._v("设置显示类型")]),e._v(" "),r("li",[e._v("指定显示方向")]),e._v(" "),r("li",[e._v("设置主题色")])])]),e._v(" "),r("li",[e._v("应用安装横幅\n"),r("ul",[r("li",[e._v("引导用户添加应用")]),e._v(" "),r("li",[e._v("引导用户安装原生应用")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"自定义名称"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义名称","aria-hidden":"true"}},[this._v("#")]),this._v(" 自定义名称")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("name：{string} 应用名称，用于安装横幅、启动画面显示")]),this._v(" "),t("li",[this._v("short_name: {string} 应用短名称，用于主屏幕显示")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("目前如果修改了manifest.json的应用名称，已添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但在未来版本的Chrome浏览器将支持名称自动更新")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"自定义图标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义图标","aria-hidden":"true"}},[this._v("#")]),this._v(" 自定义图标")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("icons：{Array.< ImageObject >} 应用图标列表")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("src: {string} 图标url")]),this._v(" "),t("li",[this._v("type {string} 图标的mime类型，非必填项，该字段可让浏览器快速忽略掉不支持的图标类型")]),this._v(" "),t("li",[this._v("sizes {string} 图标尺寸，格式为width*height，宽高数值以css的px为单位。如果需要填写多个尺寸，则使用空格进行间隔，如“48X48 96X96 128X128”")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("当PWA添加到主屏幕时，浏览器会根据有效图标的 sizes 字段进行选择。首先寻找与显示密度相匹配并且尺寸调整到 "),t("strong",[this._v("48dp 屏幕密度的图标")]),this._v("；如果未找到任何图标，则会查找与设备特性匹配度最高的图标；如果匹配到的图标路径错误，将会显示浏览器默认 icon。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("需要注意的是")]),this._v(" "),t("ol",[t("li",[this._v("在启动应用时，启动动画图像会从图标列表中提取最接近128dp的图标进行显示")]),this._v(" "),t("li",[this._v("当PWA添加到主屏幕时，浏览器会根据有效图标的 sizes 字段进行选择。首先寻找与显示密度相匹配并且尺寸调整到 48dp 屏幕密度的图标；如果未找到任何图标，则会查找与设备特性匹配度最高的图标；如果匹配到的图标路径错误，将会显示浏览器默认 icon。")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"设置启动网址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置启动网址","aria-hidden":"true"}},[this._v("#")]),this._v(" 设置启动网址")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("start_url: {string} 应用启动地址")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"设置作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 设置作用域")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("scope：{string} 作用域")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("如果没有在 manifest 中设置 scope，则默认的作用域为 manifest.json 所在文件夹；")]),e._v(" "),r("li",[e._v("scope 可以设置为 "),r("code",[e._v("../")]),e._v(" 或者更高层级的路径来扩大PWA的作用域；")]),e._v(" "),r("li",[r("code",[e._v("start_url")]),e._v(" 必须在作用域范围内；")]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("start_url")]),e._v(" 为相对地址，其根路径受 scope 所影响；")]),e._v(" "),r("li",[e._v("如果 "),r("code",[e._v("start_url")]),e._v(" 为绝对地址（以 "),r("code",[e._v("/")]),e._v(" 开头），则该地址将永远以 "),r("code",[e._v("/")]),e._v(" 作为根地址；")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"设置显示类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置显示类型","aria-hidden":"true"}},[this._v("#")]),this._v(" 设置显示类型")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("display {string} 显示类型")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",[r("thead",[r("tr",[r("th",[e._v("显示类型")]),e._v(" "),r("th",[e._v("描述")]),e._v(" "),r("th",[e._v("降级显示类型")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("fullscreen")]),e._v(" "),r("td",[e._v("应用的显示界面将占满整个屏幕")]),e._v(" "),r("td",[e._v("standalone")])]),e._v(" "),r("tr",[r("td",[e._v("standalone")]),e._v(" "),r("td",[e._v("浏览器相关UI（如导航栏、工具栏等）将会被隐藏")]),e._v(" "),r("td",[e._v("minimal-ui")])]),e._v(" "),r("tr",[r("td",[e._v("minimal-ui")]),e._v(" "),r("td",[e._v("显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同")]),e._v(" "),r("td",[e._v("browser")])]),e._v(" "),r("tr",[r("td",[e._v("browser")]),e._v(" "),r("td",[e._v("浏览器模式，与普通网页在浏览器中打开的显示一致")]),e._v(" "),r("td",[e._v("（None）")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("CSS中可以通过display-mode媒体查询条件去指定在不同的显示类型下不同的显示形式")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("@media all and (display-mode: fullscreen) {\n    body {\n        margin: 0;\n    }\n}\n\n@media all and (display-mode: standalone) {\n    body {\n        margin: 1px;\n    }\n}\n\n@media all and (display-mode: minimal-ui) {\n    body {\n        margin: 2px;\n    }\n}\n\n@media all and (display-mode: browser) {\n    body {\n        margin: 3px;\n    }\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"指定页面显示方向"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指定页面显示方向","aria-hidden":"true"}},[this._v("#")]),this._v(" 指定页面显示方向")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("orientation: {string} 应用显示方向")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("landscape-primary")]),e._v(" "),r("li",[e._v("landscape-secondary")]),e._v(" "),r("li",[e._v("landscape")]),e._v(" "),r("li",[e._v("portrait-primary")]),e._v(" "),r("li",[e._v("portrait-secondary")]),e._v(" "),r("li",[e._v("portrait")]),e._v(" "),r("li",[e._v("natural")]),e._v(" "),r("li",[e._v("any")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"设置主题颜色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置主题颜色","aria-hidden":"true"}},[this._v("#")]),this._v(" 设置主题颜色")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("theme_color：{color} css色值")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("在指定了theme_color的值之后，地址栏依然呈白色。可以在页面HTML里设置name为theme_color的meta标签")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('<meta name="theme_color" content="green">\n')])])]),t("p",[this._v("这个标签的色值会覆盖manifest.json里设置的，")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"引导用户添加应用至主屏幕"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引导用户添加应用至主屏幕","aria-hidden":"true"}},[this._v("#")]),this._v(" 引导用户添加应用至主屏幕")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("站点部署manifest.json，该文件需配置如下属性：\n"),r("ul",[r("li",[e._v("short_name")]),e._v(" "),r("li",[e._v("name")]),e._v(" "),r("li",[e._v("icons(必须"),r("strong",[e._v("包含一个mime类型为image/png的图标声明")]),e._v(")")]),e._v(" "),r("li",[e._v("start_url")]),e._v(" "),r("li",[e._v("display(必须为"),r("strong",[e._v("standalone或fullscreen")]),e._v(")")])])]),e._v(" "),r("li",[e._v("站点注册Service Worker")]),e._v(" "),r("li",[e._v("站点支持HTTPS访问")]),e._v(" "),r("li",[e._v("站点在"),r("strong",[e._v("同一浏览器中被访问至少两次")]),e._v("，"),r("strong",[e._v("两次访问间隔至少为5分钟")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"引导用户安装原生应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引导用户安装原生应用","aria-hidden":"true"}},[this._v("#")]),this._v(" 引导用户安装原生应用")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("站点部署manifest.json，该文件需配置如下属性：\n"),r("ul",[r("li",[e._v("short_name")]),e._v(" "),r("li",[e._v("name")]),e._v(" "),r("li",[e._v("icons(必须"),r("strong",[e._v("包含一个192X192且mime类型为image/png的图标声明")]),e._v(")")]),e._v(" "),r("li",[e._v("包含原生应用相关信息的"),r("strong",[e._v("related_applications对象")])])])]),e._v(" "),r("li",[e._v("站点注册Service Worker")]),e._v(" "),r("li",[e._v("站点支持HTTPS访问")]),e._v(" "),r("li",[e._v("站点在"),r("strong",[e._v("同一浏览器中被访问至少两次")]),e._v("，"),r("strong",[e._v("两次访问间隔至少为2天")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("p",[this._v("related_applications: Array.< AppInfo >关联应用列表")]),this._v(" "),t("p",[this._v("AppInfo的属性包括")]),this._v(" "),t("ul",[t("li",[this._v("platform：{string} 应用平台")]),this._v(" "),t("li",[this._v("id：{string} 应用id")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"网络推送通知"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络推送通知","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络推送通知")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"疑惑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#疑惑","aria-hidden":"true"}},[this._v("#")]),this._v(" 疑惑")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ol",[r("li",[r("p",[e._v("内容发生改变时，重新注册安装即Service Worker更新的最佳方案？")]),e._v(" "),r("p",[e._v("为了最大化利用浏览器缓存service-worker.js，但又保证一旦项目更新时浏览器能够及时更新：")]),e._v(" "),r("ul",[r("li",[e._v("将注册代码单独放置在sw-register.js中")]),e._v(" "),r("li",[e._v("将sw-register.js中实际注册service-worker.js的部分，在后面添加？v=xxx，取值为编译时间。")]),e._v(" "),r("li",[e._v("在HTML引用sw-register.js，同样在后面添加？v=xxx，但这里取值为当前时间，因为每次请求都在变化，避免浏览器对sw-register.js进行缓存。")])])]),e._v(" "),r("li",[r("p",[e._v("sw.update 事件理解？")]),e._v(" "),r("blockquote",[r("p",[e._v("注册的sw.update事件是在/components/UpdateToast.vue组件进行监听，并在更新时弹出提示，引导用户刷新页面。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("mounted() {\n        window.addEventListener('sw.update', this.handleUpdate);\n    },\n    beforeDestroy() {\n        window.removeEventListener('sw.update', this.handleUpdate);\n    },\n    \n// UpdateToast.vue做监听，若事件发生，则执行handleUpdate方法\n")])])])])]),e._v(" "),r("li",[r("p",[e._v("App shell 和 skeleton最佳实践？")]),e._v(" "),r("p",[e._v("在spa中，使用skeleton：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("在webpack中引入插件")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("//webpack.conf.js\nimport SkeletonWebpackPlugin from 'vue-skeleton-webpack-plugin';\nplugins: [\n    new SkeletonWebpackPlugin({\n        webpackConfig: require('./webpack.skeleton.conf')\n    })\n]\n\n参数说明：\nwebpackConfig必填，渲染skeleton的webpack配置对象\ninsertAfter选填，渲染DOM结果插入位置，默认值为'<div id=\"app\">'\nquiet选填，在服务端渲染时是否需要输出信息到控制台\nrouter选填，SPA下配置各个路由路径对应的Skeleton\n  -mode 选填路由模式，两个有效值history|hash\n  -routes 选填路由数组，其中每个路由对象包含两个属性：\n  \t-path路由路径\n  \t-skeletonId Skeleton DOM的id\nminimize选填，SPA下是否需要压缩注入HTML的JS代码\n")])])])]),e._v(" "),r("li",[r("p",[e._v("自动插入路由规则")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// webpack.dev.conf.js\nimport SkeletonWebpackPlugin from 'vue-skeleton-webpack-plugin';\nmodule: {\n    rules: [\n        SkeletonWebpackPlugin.loader({\n            resource: resolve('src/entry.js'),\n            options: {\n                entry: 'skeleton',\n                routePathTemplate: '/skeleton',\n                importTmplate: 'import Skeleton from \\'./Skeleton.vue\\';'\n            }\n        })\n    ]\n}\n参数：\n1.webpack模块规则，skeleton对应的路由将被插入路由文件中，需要指定一个或多个路由文件，使用resource/include/test都可以指定loader应用的文件\n2.options将被传入loader中的参数对象，包含以下属性：\n\tentry必填，支持字符串和数组类型，对应页面入口的名称\n\timportTemplate选填，引入skeleton组件的表达式，默认值为'import [nameCap] from \\'@/pages/[nameCap].vue\\';'\n\troutePathTemplate选填，默认值为'/skeleton-[name]'\n\tinsertAfter选填，路由插入位置，默认值为'routes: ['\nimportTemplate和routePathTemplate中使用占位符：\n\t[name]和entry一致\n\t[nameCap]和entry首字母大写一致\n\t[nameHash]和entry名称生成的Hash一致\n")])])])])]),e._v(" "),r("p",[e._v("在ssr中，使用appShell：")]),e._v(" "),r("p",[e._v("注意点：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("当修改完代码传到服务器上后，需要重启服务器，原因可能是因为缓存，虽然service-worker.js更新了js和css，但是第一次的服务端渲染的请求/appshell如果不重启服务器，会取上一次的cache，导致报内部的js、css找不到文件，接下来将这些错误的信息缓存到了service-worker中，就会一直报错。")])]),e._v(" "),r("li",[r("p",[e._v('当使用了appshell以后，只有第一次会服务端渲染获取appshell的值。第二次请求后，取得是缓存中的appshell，通过body标签中的data-vue-meta="empty-appshell"做标识，存在这个标识，代表从缓存中读取，接下来的页面跳转就是和spa一样，前端获取数据渲染')])]),e._v(" "),r("li",[r("p",[e._v("lavas脚手架 在ssr:true有错，appshell加载完成后没有mount。原因是"),r("strong",[e._v("异步加载了css，此时要把asyncCSS设置为false")]),e._v("；但在"),r("strong",[e._v("skeleton时，应该使用true，让skeleton更早的出现，减少白屏时间")]),e._v("（修改lavas-config.js中的配置）")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// lavas.config.js\n// spa 用true，ssr用false\ncssExtract: false,\n")])])])]),e._v(" "),r("li",[r("p",[e._v("在研究appshell时，产生了对ssr的原理理解思考？")]),e._v(" "),r("p",[e._v("ssr实际上在第一次刷新整个url时，就把完整的html和js返回到前端做混合，后面做跳转实际是router局部刷新。这个非常重要")])])])]),e._v(" "),r("li",[r("p",[e._v("Workbox 参数swSrc、globDirectory、staticFileGlobs、swDest作用？")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("swSrc")]),e._v("：模板的路径")]),e._v(" "),r("p",[r("strong",[e._v("swPath")]),e._v("：修改该配置可以指定service-worker.js的scope")]),e._v(" "),r("p",[r("strong",[e._v("swDest")]),e._v("：输出service-worker.js的路径")]),e._v(" "),r("p",[e._v("globDirectory、staticFileGlobs决定需要缓存的静态文件，这两个参数存在默认值。插件会从compilation参数中获取开发者在webpack配置的output.path作为globDirectory的默认值，staticFileGlobs的默认设置是html，js，css文件，如果需要缓存一些界面必须的图片，这个地方需要自己配置")]),e._v(" "),r("p",[r("strong",[e._v("globDirectory")]),e._v(" 指定需要预缓存的静态文件的目录")]),e._v(" "),r("p",[r("strong",[e._v("globPatterns")]),e._v(" 相对于globDirectory指定的目录，指出哪些文件需要被预缓存。")]),e._v(" "),r("p",[r("strong",[e._v("globIgnores")]),e._v(" 相对于globDirectory指定的目录，指出哪些文件不需要被预缓存")]),e._v(" "),r("p",[r("strong",[e._v("dontCacheBustUrlsMatching")]),e._v("  workbox会将符合上述glob开头的三个配置项条件的所有静态文件逐个生成一个版本号（称为revision）存入缓存，后续再面对同名文件时比较缓存中的版本号决定是否更新。可以通过这个参数的正则匹配，匹配成功的会过滤掉不在workbox中生成版本号，省略了生成和比较的过程提升构建速度。")]),e._v(" "),r("p",[r("strong",[e._v("以上参数都是workbox中的参数")])]),e._v(" "),r("p",[e._v("配置中globIgnores要配sw-register.js和** . *map。不能缓存sw-register，否则无法更新sw")]),e._v(" "),r("p",[e._v("另外，workbox返回生成的service-worker.js后，sw-register-webpack-plugin会通过sw-register.js的模板在路径后加上hash值，保证不会读浏览器的缓存。")]),e._v(" "),r("p",[e._v("插入在index.html中的引入sw-register.js的也要加上hash值，保证不会读缓存。")]),e._v(" "),r("p",[r("strong",[e._v("service-worker.js中WorkboxSW的配置项")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("cacheId：指定应用的缓存ID，会影响到缓存的名称。WorkBox还会将域名加载缓存ID中共同作为缓存名称，重名的几率会比较小")]),e._v(" "),r("li",[e._v("ignoreUrlParametersMatching：指名什么样的请求参数应该被忽略。Service Worker的静态文件缓存会根据请求URL进行匹配。只要请求URL不同则认为是不同的资源。")]),e._v(" "),r("li",[e._v("skipWaiting：在Service Worker的install阶段完成后无需等待，立即激活（activate）等同于self.skipWaiting()")]),e._v(" "),r("li",[e._v("clientsClaim：activate阶段让所有没被控制的页面控制。等同于self.clients.claim()")]),e._v(" "),r("li",[e._v("同时使用skipWaiting和clientsClaim可以让Service Worker在下载完成后立即生效")])]),e._v(" "),r("p",[r("strong",[e._v("strategies")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// JS 请求：网络优先\nworkbox.routing.registerRoute(\n\tnew RegExp(\'.*\\ .js\'),\n\tworkbox.strategies.networkFirst({\n\t\tcacheName: \'workbox:js\',\n\t})\n);\n// css 请求：缓存优先，同时后台更新后下次打开页面才会被页面使用\nworkbox.routing.registerRoute(\n\t// cache css files\n\t/.*\\ .css/,\n\tworkbox.strategies.staleWhileRevalidate({\n        cacheName: \'workbox:css\'\n\t})\n);\n// 图片请求：缓存优先\nworkbox.routing.registerRoute(\n\t/.*\\ .(?:png|jpg|jpeg|svg|gif)/,\n\tworkbox.strategies.cacheFirst({\n        cacheName: \'workbox:image\',\n        plugins: [\n            new workbox.expiration.plugin({\n                maxEntries: 20,\n                maxAgeSeconds: 7*24*60*60\n            })\n        ]\n\t})\n)\n// demo页\n<html>\n<head>\n  <link rel="stylesheet" href="./css/style.css">\n</head>\n<body>\n  <h1>Workbox Get Started</h1>\n  <img src="./images/google.local.png" alt="同域的文件">\n  <script src="./js/index.js"><\/script>\n</body>\n</html>\n')])])]),r("p",[e._v("第一次访问时的效果：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/gs1.png",alt:"gs1"}})]),e._v(" "),r("p",[e._v("fetch事件无法在这次访问被捕获")]),e._v(" "),r("p",[e._v("刷新页面的效果：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/gs2.png",alt:"gs2"}})]),e._v(" "),r("ul",[r("li",[e._v("全部的css、png、js文件均被ServiceWorker拦截")]),e._v(" "),r("li",[e._v("workbox-core在拦截后重新发起了fetch请求并返回页面，fetch后服务端"),r("strong",[e._v("返回304依然使用浏览器本地缓存策略")])]),e._v(" "),r("li",[e._v("上述命中规则的请求都被缓存到cache storage中")])]),e._v(" "),r("p",[e._v("更新css、js和png的内容，然后重新访问页面：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/gs4.png",alt:"gs4"}})]),e._v(" "),r("ul",[r("li",[e._v("由于png是cache first，所以直接从service worker的cache返回，没有真正的网络请求发出")]),e._v(" "),r("li",[e._v("js是network first，会产生fetch，且运行成功")]),e._v(" "),r("li",[e._v("css虽然同样fetch了新的内容，但页面并没有生效，用的还是上次的cache（但新的文件内容已经放到cache storage中）")])]),e._v(" "),r("p",[e._v("不做修改，再刷新页面：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/gs5.png",alt:"gs5"}})]),e._v(" "),r("ul",[r("li",[e._v("新的css生效")]),e._v(" "),r("li",[r("strong",[e._v("css、js请求返回304，使用浏览器缓存")])])]),e._v(" "),r("p",[r("strong",[e._v("离线功能")])]),e._v(" "),r("p",[e._v("要做到能够完全离线，要让主文档也能被缓存下来")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 主文档: 网络优先\nworkbox.routing.registerRoute(\n  /index\\.html/,\n  workbox.strategies.networkFirst({\n    cacheName: 'workbox:html',\n  })\n);\n")])])]),r("p",[e._v("缓存成功后，即便断网，页面依旧可以访问及使用：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/ol1.png",alt:"ol1"}})]),e._v(" "),r("p",[r("strong",[e._v("跨域请求")])]),e._v(" "),r("p",[e._v("当请求是"),r("strong",[e._v("跨域资源（不仅限于接口，也包括图片等）"),r("strong",[e._v("并且目标服务器并")]),e._v("没有设置CORS")]),e._v("时，响应类型会被设置为‘"),r("strong",[e._v("opaque")]),e._v("’并且HTTP"),r("strong",[e._v("状态码会被设置为0")]),e._v(".出于安全考虑，workbox对于这类资源的信任度不高，在使用"),r("strong",[e._v("CacheFirst策略时只缓存HTTP状态码为200的资源")]),e._v("。所以这类资源不会被缓存，当然在离线时也无法被展现")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<div>\n  <p>不同域的文件</p>\n  <p><img src="https://developers.google.com/web/tools/workbox/images/Workbox-Logo-Grey.svg" alt="不同域的文件"></p>\n\n  <p>不同域的文件 且 <code>access-control-allow-origin: *</code></p>\n  <img src="https://unpkg.com/resize-image@0.0.4/example/google.png" alt="不同域的文件 且 allow cross origin">\n</div>\n\x3c!-- 不同域的js 且 access-control-allow-origin: * --\x3e\n<script src="https://unpkg.com/jquery@3.3.1/dist/jquery.js"><\/script>\n')])])]),r("p",[e._v("Workbox可以用"),r("strong",[e._v("networkFirst")]),e._v("和"),r("strong",[e._v("staleWhileRevalidate")]),e._v("两种策略"),r("strong",[e._v("Cache跨域资源")]),e._v("，而"),r("strong",[e._v("cacheFirst")]),e._v("完全"),r("strong",[e._v("不行")]),e._v("。"),r("strong",[e._v("原因是Fetch跨域的请求是无法知道该请求是否成功，因此cacheFirst则有可能缓存下失败的请求，并从此以后都会接管页面的这个请求导致页面错误。"),r("strong",[e._v("而networkFirst和staleWhileRevalidate是有更新机制，即使错了下次修复了就好了。cacheFirst例子即使")]),e._v("开启offline")]),e._v("也能浏览到页面是因为html是同域的，而"),r("strong",[e._v("跨域资源有浏览器缓存")]),e._v("。如果同时开启"),r("strong",[e._v("disable cache")]),e._v("就"),r("strong",[e._v("无法看到相关跨域的静态资源")]),e._v("了")]),e._v(" "),r("p",[e._v("但如果执意要用cacheFirst缓存跨域资源，(cacheableResponse.Plugin)[https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.cacheableResponse.Plugin]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Force Caching of Opaque Responses\nworkbox.routing.registerRoute(\n  new RegExp('https://developers\\.google\\.com/'),\n  workbox.strategies.cacheFirst({\n    cacheName: `${CACHE_NAME}:cache-first`,\n    plugins: [\n      // Force Cache\n      new workbox.cacheableResponse.Plugin({\n        statuses: [0, 200], // One or more status codes that a Response can have and be considered cacheable.这里允许状态码为0的抢矿也缓存，可以解决跨域不缓存的问题\n      }),\n    ]\n  }),\n);\n")])])]),r("p",[e._v("此时就可以看到https://developers.google.com/域名下的资源也缓存了：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://coracain.top/assets/co1.png",alt:"co1"}})]),e._v(" "),r("p",[r("strong",[e._v("不难看出")]),e._v("，以上的routing需要"),r("strong",[e._v("第三次访问才能真正从cache中将缓存返回（或者支持离线）")]),e._v("。如果要提前至第二次，那么就要使用precache，使用precache后，会在第一次就将资源全部cache下来了。")]),e._v(" "),r("p",[r("strong",[e._v("动态缓存的注册顺序")])]),e._v(" "),r("p",[e._v("workbox的内部使用一个数组记录所有动态缓存的正则表达式。在开发者使用registerRoute时，内部调用数组的unshift方法进行扩充。因此，结论是 "),r("strong",[e._v("越后注册的规则将越先匹配")])])])]),e._v(" "),r("li",[r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("navigator.serviceWorker.register('/service-worker.js').then(function(reg) {\n        reg.onupdatefound = function() {\n            var installingWorker = reg.installing;\n            installingWorker.onstatechange = function() {\n                switch (installingWorker.state) {\n                    case 'installed':\n                        if (navigator.serviceWorker.controller) {\n                            var event = document.createEvent('Event');\n                            event.initEvent('sw.update', true, true);\n                            window.dispatchEvent(event);\n                        }\n                        break;\n                }\n            };\n        };\n其中 reg.onupdatefound/reg.installing/reg.installing.onstatechange的理解\nservice-worker事件理解\n这里注册的sw.update事件是在/components/UpdateToast.vue组件进行监听，并在更新时弹出提示，引导用户刷新页面。\n")])])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ios-pwa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ios-pwa","aria-hidden":"true"}},[this._v("#")]),this._v(" IOS pwa")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"配置index-html文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置index-html文件","aria-hidden":"true"}},[this._v("#")]),this._v(" 配置index.html文件")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  \x3c!-- The usual suspects --\x3e\n  <meta charset="utf-8">\n  <meta name="description"\n        content="My app is awesome because...">\n  <title>My awesome app</title>\n  <link rel="shortcut icon"\n        href="%PUBLIC_URL%/favicon.ico">\n  \n  \x3c!-- Use viewport-fit=cover to fill the iPhone X notch and also prevent content going under the status bar (if it\'s translucent) --\x3e\n  \x3c!-- More info: https://css-tricks.com/the-notch-and-css/ --\x3e\n  <meta name="viewport"\n        content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover">\n\n  \x3c!-- More PWA settings are in the manifest: https://gist.github.com/sconstantinides/8181934ecf82acde62589bac379f6676 --\x3e\n  <link rel="manifest"\n        href="%PUBLIC_URL%/manifest.json">\n  \n  \x3c!-- Android: Define the nav bar color --\x3e\n  \x3c!-- More info: https://developers.google.com/web/fundamentals/design-and-ux/browser-customization/#color_browser_elements --\x3e\n  <meta name="theme-color"\n        content="#32324B">\n  \n  \x3c!-- iOS specific styles --\x3e\n  \n  <meta name="apple-mobile-web-app-capable"\n        content="yes">\n  \n  \x3c!-- Possible values include default, black, or black-translucent; only black-translucent is truly full screen --\x3e\n  \x3c!-- More info: https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html --\x3e\n  <meta name="apple-mobile-web-app-status-bar-style"\n        content="black-translucent">\n  \n  \x3c!-- Home screen icon --\x3e\n  <link rel="apple-touch-icon"\n        href="%PUBLIC_URL%/images/appIcon.png">\n\n  \x3c!-- iOS startup images --\x3e\n  \x3c!-- More info and Sketch template: https://medium.com/@applification/progressive-web-app-splash-screens-80340b45d210 --\x3e\n  \n  \x3c!-- iPhone SE --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-640x1136.png"\n        media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-640x1136-landscape.png"\n        media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n  \n  \x3c!-- iPhone 6/7/8 --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-750x1294.png"\n        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-750x1294-landscape.png"\n        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">\n  \n  \x3c!-- iPhone 6+/7+/8+ --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1242x2148.png"\n        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1242x2148-landscape.png"\n        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n  \n  \x3c!-- iPhone X --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1125x2436.png"\n        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1125x2436-landscape.png"\n        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">\n  \n  \x3c!-- iPad 3/4/Pro 9.7" --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1536x2048.png"\n        media="(min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1536x2048-landscape.png"\n        media="(min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape)">\n  \n  \x3c!-- iPad Pro 10.5" --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1668x2224.png"\n        media="(min-device-width: 834px) and (max-device-width: 834px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-1668x2224-landscape.png"\n        media="(min-device-width: 834px) and (max-device-width: 834px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape)">\n  \n  \x3c!-- iPad Pro 12.9" --\x3e\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-2048x2732.png"\n        media="(min-device-width: 1024px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)">\n  <link rel="apple-touch-startup-image"\n        href="%PUBLIC_URL%/images/launch-2048x2732-landscape.png"\n        media="(min-device-width: 1024px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape)">\n</head>\n\n<body>\n  <div id="root"></div>\n</body>\n\n</html>\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"设计一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一致性","aria-hidden":"true"}},[this._v("#")]),this._v(" 设计一致性")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('/* Replace "standalone" with "fullscreen" depending on your manifest.json display mode */\n\n@media (display-mode: standalone) {\n  /* All installed PWAs */\n}\n\n@media (max-width: 576px) and (display-mode: standalone) {\n  /* Installed PWAs on mobile devices */\n  \n  @supports (-webkit-overflow-scrolling: touch) {\n    /* Installed PWAs on mobile Apple devices */\n  }\n  \n  @supports not (-webkit-overflow-scrolling: touch) {\n    /* Installed PWAs on mobile non-Apple devices */\n  }\n}\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("if (window.matchMedia('(display-mode: standalone)').matches) {\n  // Is installed in standalone display mode\n}\n\nif (window.matchMedia('(display-mode: fullscreen)').matches) {\n  // Is installed in fullscreen display mode\n}\n")])])])}],!1,null,null,null);s.options.__file="Damn-hole-of-pwa.md";t.default=s.exports}}]);